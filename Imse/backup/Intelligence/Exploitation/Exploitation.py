import pickle
import numpy
import random
import math

class Exploitation(object):
    
    '''Program parameters'''

    def __init__(self, images_number_iteration, images_number_total, category):
        self.setsize = images_number_iteration
        self.images_number = images_number_total
        self.category = category
        self.images_shown = []
        self.previouse_images = []
        self.feedback = []
        self.iteration = 0
        self.selected_images = []
        
    
    def FirstRound(self):
        
        '''Pre-processing stage - sample first set of images
        Take random images from different clusters 
        because they are the most remote ones'''
        all_images = numpy.arange(0, self.images_number)
        #if(self.category == "None"):
        images_per_group = int(math.ceil(self.images_number / self.setsize))
        #else:
            #images_per_group = 2 * int(math.ceil(self.images_number / self.setsize))
        
        images = []
        
        image_counter = 0
        while(image_counter < self.images_number -1):
            if((self.images_number - image_counter) >= images_per_group) and ((self.images_number - image_counter) < 2 * images_per_group):
                images_group = all_images[image_counter:]
                image_counter = self.images_number
            else:
                images_group = all_images[image_counter:image_counter + images_per_group]
                image_counter += images_per_group
            
            numpy.random.shuffle(images_group)
            image = images_group[0]
            images.append(image)
        '''
        numpy.random.shuffle(all_images)
        images = []
        for i in all_images[:self.setsize]:
            images.append(i)
        '''
        '''
        if(self.category != "None"):
            tags = pickle.load(open("/data/Imse/Data/tag_to_img_" + str(self.images_number)))
            candidates = tags[self.category]
            images_from_selected_category = random.sample(candidates, self.setsize / 2)
            images.extend(images_from_selected_category)
        '''
        random.shuffle(images)

        self.images_shown = images
        self.previouse_images = images
        self.iteration += 1
        return images
    
    def Predict(self, feedback, data):

        
        '''# All the images that were selected in this trial
        attempts = []'''
        self.feedback = self.feedback + feedback
        
        average_image = (data[:self.images_number,:self.images_number])[self.images_shown,:]        
        ratings = numpy.zeros((self.images_number))
        for i in range(len(self.feedback)):
            line = average_image[i,:]*self.feedback[i]
            print len(line)
            ratings += line        
        sorted_images = numpy.argsort(ratings)[::-1]
        
        
        # Get selected images
        # Images for which the user gave implicite feedback
        # We don't want to show them again
        i = 0
        for f in feedback:
            #if f!=0:
            self.selected_images.append(self.previouse_images[i])
            i += 1    

        # What this method returns
        images = []
        
        i = 0
        while len(images)<self.setsize:       
            if sorted_images[i] not in self.previouse_images and sorted_images[i] not in self.images_shown:
                if sorted_images[i] not in self.selected_images:
                    images.append(sorted_images[i])
            i += 1
        self.images_shown = self.images_shown + images
        self.iteration += 1
        self.previouse_images = images
        return images